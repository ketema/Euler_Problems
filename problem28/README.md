# Project Euler Problem 28: Number Spiral Diagonals

## Problem Statement

Starting with the number 1 and moving to the right in a clockwise direction, a 5 by 5 spiral is formed as follows:

```
21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13
```

It can be verified that the sum of the numbers on the diagonals is 101.

What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?

## Approach

### Pattern Recognition

Instead of building the entire spiral, we can find a pattern in the diagonal values:

**Layer 1** (center): 1
**Layer 2** (3×3): Top-right = 3, 5, 7, 9 (skip by 2)
**Layer 3** (5×5): Top-right = 13, 17, 21, 25 (skip by 4)
**Layer 4** (7×7): Skip by 6

**Pattern for layer n (odd size):**
- We add 4 corners per layer
- The increment between corners = (n-1)
- Start from previous top-right value

### Mathematical Formula

For a spiral of size n×n (n must be odd):

```
Starting from value = 1 (center)
For each layer size = 3, 5, 7, ..., n (step by 2):
    increment = layer - 1
    Add 4 corners: value+inc, value+2*inc, value+3*inc, value+4*inc
    Update value to last corner
```

### Complexity

- **Time**: O(n) - one pass through layers
- **Space**: O(1) - only tracking running sum
- For n = 1001: ~500 iterations (very fast!)

## Implementation Details

- **Language**: Crystal 1.11.2
- **Why Crystal**:
  - **First Crystal solution in repository!**
  - Object-oriented language (Ruby-like syntax)
  - Compiled to native code (LLVM)
  - Static typing with type inference
  - Blazing fast execution (~1.3 milliseconds!)
  - Built-in Spec testing framework

### Object-Oriented Design

```crystal
class NumberSpiral
  def initialize(@size : Int32)
    # Validates size is odd
  end

  def diagonal_sum : Int64
    # Calculates sum using pattern
  end

  def self.solve(size : Int32 = 1001) : Int64
    # Class method for convenience
  end
end
```

**Key OOP Features:**
- **Encapsulation**: Size stored as instance variable
- **Validation**: Constructor ensures size is odd
- **Type Safety**: Explicit types prevent overflow (Int64 for large sums)
- **Class Methods**: Convenient solve() interface
- **Single Responsibility**: Class focused on spiral diagonal calculation

## TDD Methodology

Following AGENTS.md constitutional framework:

### Tests Written (10 test cases) ✓

**Initialization:**
- Creates spiral with odd size ✓
- Raises error for even size ✓
- Accepts size 1 (edge case) ✓

**Diagonal Sum Calculations:**
- 1×1 spiral = 1 ✓
- 3×3 spiral = 25 ✓
- 5×5 spiral = 101 ✓
- 7×7 spiral = 261 ✓

**Solve Method:**
- Solves for default size 1001 ✓
- Solves for custom size ✓
- Returns Int64 type ✓

**All tests passing!** ✓

## Answer

**669,171,001**

For a 1001×1001 spiral.

**Verification:**
- Pattern holds for all test cases
- Matches known result for 5×5 (101)
- Runs in ~1.3 milliseconds

## Performance

Crystal's compiled nature makes this incredibly fast:

- **Compilation**: ~1 second
- **Execution**: **1.3 milliseconds**
- **Total**: ~1 second

This is **orders of magnitude faster** than interpreted languages!

## Running the Solution

```bash
# Navigate to directory
cd problem28/crystal

# Run tests
crystal spec number_spiral_spec.cr

# Run solution
crystal run number_spiral.cr

# Compile and run (faster)
crystal build number_spiral.cr --release
./number_spiral

# Run with custom size
crystal run number_spiral.cr -- 5
```

## Sample Output

```
$ crystal run number_spiral.cr
Problem 28: Number Spiral Diagonals (1001×1001)
Answer: 669171001

$ crystal spec number_spiral_spec.cr
..........
Finished in 1.3 milliseconds
10 examples, 0 failures, 0 errors, 0 pending
```

## Crystal Language Features Used

- **Classes**: OOP with instance variables
- **Type Annotations**: `@size : Int32`, `Int64`
- **Ranges & Iterators**: `(2..@size).step(2).each`
- **Blocks**: `.each do |layer|`
- **Class Methods**: `self.solve`
- **Exception Handling**: `raise ArgumentError`
- **Type Safety**: Prevents integer overflow
- **Spec Framework**: Built-in testing
- **Command Line Args**: `ARGV`

## Mathematical Insight

The spiral can be generated by the formula:

For layer k (where k = 1 is center, k = 2 is 3×3, etc.):
- Size of layer = 2k - 1
- Increment between corners = 2(k-1)
- Four corners per layer

**Sum formula (closed form):**
```
For n×n spiral where n = 2m + 1:
Sum = (16m³ + 30m² + 26m + 3) / 3
```

For n = 1001, m = 500:
```
Sum = (16×500³ + 30×500² + 26×500 + 3) / 3
    = (2,000,000,000 + 7,500,000 + 13,000 + 3) / 3
    = 2,007,513,003 / 3
    = 669,171,001 ✓
```

## Example Walkthrough

**3×3 Spiral:**
```
7 8 9
6 1 2
5 4 3

Corners of outer layer: 3, 5, 7, 9
Center: 1
Diagonals: 7+5+3+9+1 = 25 ✓
```

**Building pattern:**
- Start: value = 1, sum = 1
- Layer 2 (3×3), increment = 2:
  - Corner 1: 1+2 = 3, sum = 4
  - Corner 2: 3+2 = 5, sum = 9
  - Corner 3: 5+2 = 7, sum = 16
  - Corner 4: 7+2 = 9, sum = 25 ✓

## Code Metrics

**Main Solution**: 17 lines (excluding comments/blanks)
- Class definition: 3 lines
- Initialize: 2 lines
- Diagonal sum logic: 8 lines
- Class method: 2 lines
- Main execution: 2 lines

**Very concise and elegant!**

## Learning Notes

This is the **first Crystal solution** in the repository!

Demonstrates:
- Crystal's OOP capabilities
- Ruby-like syntax with static typing
- Compiled language performance (1.3ms!)
- Pattern recognition in spirals
- Type safety preventing bugs
- Built-in testing framework

**Language Count**: 25 different languages now used in this repository!

## Comparison: OOP vs Procedural

**Crystal (OOP)**: 17 lines, encapsulated, type-safe, testable
**Procedural equivalent**: ~10 lines, less structure, harder to test

OOP provides:
- Better organization
- Easier testing
- Validation in constructor
- Reusable class
- Clear interface

## Fun Facts

1. The spiral is also called **Ulam spiral** (different construction but similar idea)
2. For n×n spiral, there are 2n-1 diagonal elements
3. The center is always 1
4. Each layer adds exactly 4 corner values
5. The pattern grows quadratically (as expected from n² formula)
6. Crystal compiles to LLVM IR, making it as fast as C!
