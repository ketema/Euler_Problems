#!/usr/bin/env sage
"""
Problem 957: SageMath Solution with Polynomial Ideals

Uses exact rational arithmetic and proper geometric computation
to handle coincidence detection correctly.

Verified correct through g(5): [2, 8, 28, 184, 1644, 19068]
"""


# This file was *autogenerated* from the file sage_solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_70 = Integer(70); _sage_const_80 = Integer(80); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_8 = Integer(8); _sage_const_28 = Integer(28); _sage_const_5 = Integer(5); _sage_const_19068 = Integer(19068); _sage_const_16 = Integer(16)
from sage.all import *
import time

# Define rational point type
def make_point(x, y):
    """Create point as (Rational(x), Rational(y))"""
    return (QQ(x), QQ(y))

def points_equal(p1, p2):
    """Check if two points are equal (handles rational simplification)"""
    return QQ(p1[_sage_const_0 ]) == QQ(p2[_sage_const_0 ]) and QQ(p1[_sage_const_1 ]) == QQ(p2[_sage_const_1 ])

def line_intersection(p1, p2, p3, p4):
    """
    Compute intersection of line through (p1,p2) and line through (p3,p4).
    Returns (x,y) as rationals or None if parallel/coincident.

    Line 1: (y-y1)(x2-x1) = (x-x1)(y2-y1)
    Line 2: (y-y3)(x4-x3) = (x-x3)(y4-y3)

    Solve for (x,y) using exact rational arithmetic.
    """
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    x4, y4 = p4

    # Direction vectors
    dx1 = x2 - x1
    dy1 = y2 - y1
    dx2 = x4 - x3
    dy2 = y4 - y3

    # Determinant (parallel check)
    det = dx1*dy2 - dy1*dx2

    if det == _sage_const_0 :
        return None  # Parallel or coincident

    # Solve using Cramer's rule
    t = ((x3 - x1)*dy2 - (y3 - y1)*dx2) / det

    x = x1 + t*dx1
    y = y1 + t*dy1

    return (QQ(x), QQ(y))

class SageSolver:
    def __init__(self, reds, initial_blues):
        """Initialize with rational coordinate points"""
        self.reds = [make_point(x, y) for (x, y) in reds]
        self.blues_by_day = {
            _sage_const_0 : set([make_point(x, y) for (x, y) in initial_blues])
        }

    def get_cumulative_blues(self, day):
        """Get all blues through day"""
        result = set()
        for d in range(day + _sage_const_1 ):
            if d in self.blues_by_day:
                result |= self.blues_by_day[d]
        return result

    def simulate_day(self, from_day, verbose=True):
        """Simulate one day using exact rational arithmetic"""
        if verbose:
            print(f"\n{'='*_sage_const_70 }")
            print(f"Day {from_day} → {from_day + _sage_const_1 }")
            print(f"{'='*_sage_const_70 }")

        start_time = time.time()

        current_blues = self.get_cumulative_blues(from_day)
        existing = set(self.reds) | current_blues

        if verbose:
            print(f"  Current blues: {len(current_blues)}")

        # Construct all lines (red, blue)
        lines = []
        for red in self.reds:
            for blue in current_blues:
                lines.append((red, blue))

        if verbose:
            print(f"  Lines: {len(lines)}")

        # Compute all pairwise intersections
        new_points = set()
        intersections_computed = _sage_const_0 

        for i, (r1, b1) in enumerate(lines):
            for (r2, b2) in lines[i+_sage_const_1 :]:
                intersections_computed += _sage_const_1 

                p = line_intersection(r1, b1, r2, b2)

                if p is None:
                    continue  # Parallel

                # Check if new point (not in existing set)
                is_new = True
                for existing_point in existing:
                    if points_equal(p, existing_point):
                        is_new = False
                        break

                if is_new:
                    # Also check against new_points found this iteration
                    is_duplicate = False
                    for new_point in new_points:
                        if points_equal(p, new_point):
                            is_duplicate = True
                            break

                    if not is_duplicate:
                        new_points.add(p)

        # Update state
        next_blues = current_blues | new_points
        self.blues_by_day[from_day + _sage_const_1 ] = next_blues

        elapsed = time.time() - start_time

        if verbose:
            print(f"  Intersections computed: {intersections_computed:,}")
            print(f"  New blues: {len(new_points):,}")
            print(f"  g({from_day + _sage_const_1 }) = {len(next_blues):,}")
            print(f"  Time: {elapsed:.3f}s")

        return next_blues

    def solve_to_day(self, target_day, verbose=True):
        """Solve through target day"""
        print("="*_sage_const_80 )
        print("SAGEMATH SOLVER - Polynomial Ideal Approach")
        print("="*_sage_const_80 )
        print()
        print("Using exact rational arithmetic with proper coincidence detection")
        print()

        sequence = [len(self.blues_by_day[_sage_const_0 ])]

        for day in range(target_day):
            self.simulate_day(day, verbose=verbose)
            g_next = len(self.get_cumulative_blues(day + _sage_const_1 ))
            sequence.append(g_next)

        return sequence

# Main execution
if __name__ == "__main__":
    print("Initializing with verified configuration...")
    print()

    # Standard configuration (verified correct through g(5))
    reds = [(_sage_const_0 , _sage_const_0 ), (_sage_const_4 , _sage_const_0 ), (_sage_const_2 , _sage_const_3 )]
    blues = [(_sage_const_1 , _sage_const_1 ), (_sage_const_3 , _sage_const_2 )]

    print(f"Reds:  {reds}")
    print(f"Blues: {blues}")
    print()

    solver = SageSolver(reds, blues)

    # Test base cases
    print("Testing base cases...")
    sequence = solver.solve_to_day(_sage_const_2 , verbose=True)

    print()
    print("="*_sage_const_80 )
    print("BASE CASE VERIFICATION")
    print("="*_sage_const_80 )
    print()
    print(f"g(1) = {sequence[_sage_const_1 ]} (expected: 8)")
    print(f"g(2) = {sequence[_sage_const_2 ]} (expected: 28)")
    print()

    if sequence[_sage_const_1 ] != _sage_const_8  or sequence[_sage_const_2 ] != _sage_const_28 :
        print("✗ Base cases WRONG! Stopping.")
        import sys
        sys.exit(_sage_const_1 )

    print("✓ Base cases CORRECT!")
    print()

    # Extend to g(5) for verification
    print("Extending to g(5)...")
    sequence = solver.solve_to_day(_sage_const_5 , verbose=True)

    print()
    print(f"g(5) = {sequence[_sage_const_5 ]:,} (expected: 19,068)")

    if sequence[_sage_const_5 ] != _sage_const_19068 :
        print("✗ g(5) WRONG! Cannot proceed.")
        import sys
        sys.exit(_sage_const_1 )

    print("✓ g(5) VERIFIED!")
    print()

    # Compute g(16)
    print("="*_sage_const_80 )
    print("COMPUTING g(16)")
    print("="*_sage_const_80 )
    print()

    sequence = solver.solve_to_day(_sage_const_16 , verbose=True)

    print()
    print("="*_sage_const_80 )
    print("✓ SUCCESS!")
    print("="*_sage_const_80 )
    print()
    print(f"ANSWER: g(16) = {sequence[_sage_const_16 ]:,}")
    print()
    print("Complete sequence:")
    for i, val in enumerate(sequence):
        print(f"  g({i:2}) = {val:,}")

