#!/usr/bin/env sage

"""
CRITICAL PATTERN ANALYSIS - 7 Data Points

After computing g(7), we now have:
g(0)=2, g(1)=8, g(2)=28, g(3)=184, g(4)=1644, g(5)=19068, g(6)=256388, g(7)=3748844

Growth function:
new(2)=6, new(8)=20, new(28)=156, new(184)=1460, new(1644)=17424, new(19068)=237320, new(256388)=3492456

QUESTIONS:
1. Ratios: 3.5, 6.6, 8.9, 11.6, 13.4, 14.6 - is there a pattern?
2. Are we approaching saturation or is growth unbounded?
3. Can we fit a better model with 7 points?
4. Should we implement EGGlog approach instead?
"""


# This file was *autogenerated* from the file pattern_analysis_7points.sage
from sage.all_cmdline import *   # import sage library

_sage_const_70 = Integer(70); _sage_const_2 = Integer(2); _sage_const_8 = Integer(8); _sage_const_28 = Integer(28); _sage_const_184 = Integer(184); _sage_const_1644 = Integer(1644); _sage_const_19068 = Integer(19068); _sage_const_256388 = Integer(256388); _sage_const_3748844 = Integer(3748844); _sage_const_6 = Integer(6); _sage_const_20 = Integer(20); _sage_const_156 = Integer(156); _sage_const_1460 = Integer(1460); _sage_const_17424 = Integer(17424); _sage_const_237320 = Integer(237320); _sage_const_3492456 = Integer(3492456); _sage_const_1 = Integer(1); _sage_const_0p001 = RealNumber('0.001'); _sage_const_1p5 = RealNumber('1.5'); _sage_const_1p6 = RealNumber('1.6'); _sage_const_1p7 = RealNumber('1.7'); _sage_const_1p8 = RealNumber('1.8'); _sage_const_1p9 = RealNumber('1.9'); _sage_const_2p0 = RealNumber('2.0'); _sage_const_2p1 = RealNumber('2.1'); _sage_const_2p2 = RealNumber('2.2'); _sage_const_100 = Integer(100); _sage_const_17 = Integer(17); _sage_const_7 = Integer(7); _sage_const_10 = Integer(10); _sage_const_16 = Integer(16); _sage_const_0 = Integer(0); _sage_const_15 = Integer(15); _sage_const_0p00 = RealNumber('0.00'); _sage_const_0p01 = RealNumber('0.01'); _sage_const_0p20 = RealNumber('0.20'); _sage_const_9p56 = RealNumber('9.56'); _sage_const_806p88 = RealNumber('806.88'); _sage_const_84 = Integer(84); _sage_const_3600 = Integer(3600)
from sage.all import *
import math

print("="*_sage_const_70 )
print("PATTERN ANALYSIS WITH 7 DATA POINTS")
print("="*_sage_const_70 )
print()

# Growth sequence
g_values = [_sage_const_2 , _sage_const_8 , _sage_const_28 , _sage_const_184 , _sage_const_1644 , _sage_const_19068 , _sage_const_256388 , _sage_const_3748844 ]

# Growth function data
growth_data = [
    (_sage_const_2 , _sage_const_6 ),
    (_sage_const_8 , _sage_const_20 ),
    (_sage_const_28 , _sage_const_156 ),
    (_sage_const_184 , _sage_const_1460 ),
    (_sage_const_1644 , _sage_const_17424 ),
    (_sage_const_19068 , _sage_const_237320 ),
    (_sage_const_256388 , _sage_const_3492456 ),
]

print("SEQUENCE DATA:")
print()
for i, g in enumerate(g_values):
    print(f"  g({i}) = {g:,}")
print()

print("="*_sage_const_70 )
print("RATIO ANALYSIS")
print("="*_sage_const_70 )
print()

ratios = []
for i in range(len(g_values)-_sage_const_1 ):
    ratio = float(g_values[i+_sage_const_1 ]) / float(g_values[i])
    ratios.append(ratio)
    print(f"  g({i+_sage_const_1 })/g({i}) = {ratio:.6f}")

print()
print("Ratio differences (checking for arithmetic pattern):")
for i in range(len(ratios)-_sage_const_1 ):
    diff = ratios[i+_sage_const_1 ] - ratios[i]
    print(f"  Δr({i}) = {diff:.6f}")

print()
print("ANALYSIS:")
if ratios[-_sage_const_1 ] < ratios[-_sage_const_2 ]:
    print("  ✓ Ratios are DECREASING - potential saturation")
    print(f"    Latest: {ratios[-_sage_const_1 ]:.4f} < {ratios[-_sage_const_2 ]:.4f}")
else:
    print(f"  ✗ Ratios still INCREASING - no saturation")
    print(f"    Latest: {ratios[-_sage_const_1 ]:.4f} > {ratios[-_sage_const_2 ]:.4f}")

print()

print("="*_sage_const_70 )
print("GROWTH FUNCTION ANALYSIS")
print("="*_sage_const_70 )
print()

print("Growth function data: new(m)")
print()
for m, new in growth_data:
    print(f"  new({m:,}) = {new:,}")
print()

# Analyze new(m)/m² ratio
print("Checking new(m)/m² convergence:")
print()
ratios_m2 = []
for m, new in growth_data:
    ratio = float(new) / float(m**_sage_const_2 )
    ratios_m2.append(ratio)
    print(f"  new({m:,})/m² = {ratio:.8f}")

print()
print("Is new(m)/m² converging?")
for i in range(len(ratios_m2)-_sage_const_1 ):
    diff = ratios_m2[i+_sage_const_1 ] - ratios_m2[i]
    print(f"  Δ({i}) = {diff:.8f}")

print()
if abs(ratios_m2[-_sage_const_1 ] - ratios_m2[-_sage_const_2 ]) < _sage_const_0p001 :
    print("  ✓ CONVERGENCE DETECTED - new(m)/m² ≈ constant")
    print(f"    Limiting value ≈ {ratios_m2[-_sage_const_1 ]:.6f}")
else:
    print(f"  ⚠ Still varying significantly")
    print(f"    Latest change: {abs(ratios_m2[-_sage_const_1 ] - ratios_m2[-_sage_const_2 ]):.6f}")

print()

# Check new(m)/m^k for different k
print("="*_sage_const_70 )
print("TESTING POWER LAW: new(m) = c·m^k")
print("="*_sage_const_70 )
print()

for k in [_sage_const_1p5 , _sage_const_1p6 , _sage_const_1p7 , _sage_const_1p8 , _sage_const_1p9 , _sage_const_2p0 , _sage_const_2p1 , _sage_const_2p2 ]:
    ratios_k = [float(new) / float(m**k) for m, new in growth_data]
    variance = sum((ratios_k[i+_sage_const_1 ] - ratios_k[i])**_sage_const_2  for i in range(len(ratios_k)-_sage_const_1 ))
    print(f"k = {k:.1f}: variance = {variance:.6f}, latest ratio = {ratios_k[-_sage_const_1 ]:.6f}")

print()

# Check exponential growth
print("="*_sage_const_70 )
print("TESTING EXPONENTIAL: new(m) = c·exp(d·m)")
print("="*_sage_const_70 )
print()

log_new = [math.log(new) for _, new in growth_data]
log_m = [math.log(m) for m, _ in growth_data]

# Linear fit to log-log
A = matrix(QQ, [[log_m[i], _sage_const_1 ] for i in range(len(log_m))])
b_vec = vector(RR, log_new)
ATA = A.transpose() * A
ATb = A.transpose() * b_vec
solution = ATA.solve_right(ATb)
k_fit, log_c = solution

print(f"Log-log fit: log(new) = {k_fit:.6f}·log(m) + {log_c:.6f}")
print(f"Power law: new(m) ≈ {math.exp(float(log_c)):.6f}·m^{k_fit:.6f}")
print()

# Verify fit quality
print("Fit quality:")
for i, (m, new_actual) in enumerate(growth_data):
    new_predicted = math.exp(float(log_c)) * (m ** float(k_fit))
    error = abs(new_predicted - new_actual) / new_actual * _sage_const_100 
    print(f"  m={m:7,}: predicted={new_predicted:10,.0f}, actual={new_actual:7,}, error={error:5.2f}%")

print()

print("="*_sage_const_70 )
print("EXTRAPOLATION TO g(16)")
print("="*_sage_const_70 )
print()

c_fit = math.exp(float(log_c))
print(f"Using power law: new(m) ≈ {c_fit:.6f}·m^{k_fit:.6f}")
print()

m_current = Integer(_sage_const_2 )
g_sequence_extrapolated = [m_current]

print(f"g(0) = {m_current}")

for day in range(_sage_const_1 , _sage_const_17 ):
    # Use power law
    new_points = c_fit * (float(m_current) ** float(k_fit))
    new_points_int = Integer(round(new_points))

    m_current = m_current + new_points_int
    g_sequence_extrapolated.append(m_current)

    if day <= _sage_const_7 :
        expected = g_values[day]
        error = abs(m_current - expected)
        pct_error = _sage_const_100  * float(error) / float(expected)
        match = "✓" if pct_error < _sage_const_10  else "✗"
        print(f"g({day:2d}) = {m_current:20,} (expected {expected:10,}, error {pct_error:5.2f}%) {match}")
    else:
        print(f"g({day:2d}) = {m_current:20,}")

print()
print("="*_sage_const_70 )
print(f"EXTRAPOLATED g(16) = {g_sequence_extrapolated[_sage_const_16 ]:,}")
print("="*_sage_const_70 )
print()

# Sanity checks
print("Sanity checks:")
if g_sequence_extrapolated[_sage_const_16 ] > _sage_const_0 :
    print(f"  ✓ Result is positive")
if all(g_sequence_extrapolated[i+_sage_const_1 ] > g_sequence_extrapolated[i] for i in range(_sage_const_16 )):
    print(f"  ✓ Sequence is monotonically increasing")
if g_sequence_extrapolated[_sage_const_16 ] < _sage_const_10 **_sage_const_15 :
    print(f"  ✓ Result is reasonable PE size (< 10^15)")
elif g_sequence_extrapolated[_sage_const_16 ] < _sage_const_10 **_sage_const_100 :
    print(f"  ⚠ Result is large but not absurd (< 10^100)")
else:
    print(f"  ✗ Result is absurdly large: LIKELY INVALID")

print()
print("="*_sage_const_70 )
print("TIMING ANALYSIS")
print("="*_sage_const_70 )
print()

timings = [_sage_const_0p00 , _sage_const_0p00 , _sage_const_0p00 , _sage_const_0p01 , _sage_const_0p20 , _sage_const_9p56 , _sage_const_806p88 ]
print("Computation times:")
for i, t in enumerate(timings):
    print(f"  g({i+_sage_const_1 }) took {t:.2f}s")

print()
print("Timing ratios:")
for i in range(_sage_const_1 , len(timings)):
    if timings[i-_sage_const_1 ] > _sage_const_0 :
        ratio = timings[i] / timings[i-_sage_const_1 ]
        print(f"  t({i+_sage_const_1 })/t({i}) = {ratio:.2f}x")

print()
print("Estimated g(8) time:")
if len(timings) >= _sage_const_2 :
    # Use last two ratios
    ratio_6_7 = timings[-_sage_const_1 ] / timings[-_sage_const_2 ] if timings[-_sage_const_2 ] > _sage_const_0  else _sage_const_84 
    estimated_g8_time = timings[-_sage_const_1 ] * ratio_6_7
    print(f"  Based on g(6)->g(7) ratio ({ratio_6_7:.1f}x): {estimated_g8_time:.0f}s = {estimated_g8_time/_sage_const_3600 :.1f} hours")
    print()
    if estimated_g8_time > _sage_const_3600 :
        print("  ✗ g(8) is COMPUTATIONALLY INTRACTABLE with current approach")
        print("    Need alternative: EGGlog symbolic rewriting or better algorithm")

print()
print("="*_sage_const_70 )

