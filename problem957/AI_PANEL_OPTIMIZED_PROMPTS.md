# AI PANEL OPTIMIZED PROMPTS FOR PROBLEM 957

Generated by AI Panel (GPT-4.1 + Claude Sonnet 4.5) in PARALLEL mode
Date: 2025-11-11
Purpose: Structure systematic mathematical exploration using DETERMINISTIC tools

---

## PROMPT 1: Projective Geometry Incidence Structure Analysis

**OBJECTIVE:** Determine if problem maps to known projective/incidence structures with closed-form formulas.

**DETERMINISTIC TOOLS:**
- SymPy 1.14.0: `Point`, `Line`, `intersection()` with `Rational` arithmetic
- NetworkX 3.5: `Graph()`, `bipartite.complete_bipartite_graph()`
- Custom computation: incidence matrix construction

**COMPUTATIONAL PROCEDURE:**
```
STEP 1: Using SymPy with exact Rational coordinates:
  - Define 3 red points: r1, r2, r3 as Point(Rational(x), Rational(y))
  - Define 2 blue points: b1, b2 as Point(Rational(x), Rational(y))
  - Test configuration: r = [(0,0), (4,0), (2,3)], b = [(1,1), (3,2)]

STEP 2: For day n=1:
  - Construct all lines: Line(ri, bj) for i∈{1,2,3}, j∈{1,2}
  - Store as SymPy Line objects (exact representation)
  - Compute all pairwise intersections: line_i.intersection(line_j)
  - Filter: exclude red/blue points, keep only Point objects
  - COUNT: |new_blue_points|

STEP 3: Compare against known structures:
  - If count = 6: matches complete bipartite graph K_{3,2}
  - If count = 8: matches specific projective plane embedding
  - Compute: Turán graph T(5,2) has e = floor(4*5/4) = 5 edges
  - Check: Does incidence structure match PG(2,q) parameters?

STEP 4: Iterate days 2-4:
  - Update blue_set with new points
  - Recompute all Line(red, blue) combinations
  - Track growth sequence: [g(0), g(1), g(2), g(3), g(4)]
  - Compute ratios: g(n+1)/g(n) for n=0..3
```

**MEASURABLE SUCCESS CRITERIA:**
- Exact match: g(1)=8, g(2)=28, g(3)=184, g(4)=1644 (verified)
- Growth ratio analysis: if ratio converges to constant λ, check λ against algebraic integers
- If ratios form sequence A######, lookup in oeis library

**CHAINING LOGIC:**
- IF growth is polynomial: → PROMPT 2 (fit polynomial coefficients)
- IF growth is exponential with algebraic base: → PROMPT 3 (analyze eigenvalues)
- IF structure matches PG(2,q): → PROMPT 4 (projective formula derivation)
- IF ratios match OEIS sequence: → PROMPT 5 (formula from sequence properties)

**OUTPUT FORMAT:**
```json
{
  "verified_sequence": [2, 8, 28, 184, 1644],
  "growth_ratios": [4.0, 3.5, 6.571, 8.935],
  "ratio_pattern": "non-constant, describe trend",
  "incidence_structure": "type or 'unknown'",
  "oeis_match": "A###### or null",
  "next_prompt": 2
}
```

---

## PROMPT 2: Algebraic Polynomial/Recurrence Fitting

**OBJECTIVE:** Use symbolic regression and recurrence solving to find closed-form expression for g(n).

**DETERMINISTIC TOOLS:**
- PySR 1.5.9: `PySRRegressor` with exact arithmetic operators
- SymPy 1.14.0: `rsolve()` for recurrence relations, `Rational` arithmetic
- NumPy 2.3.4: matrix operations for difference equations

**COMPUTATIONAL PROCEDURE:**
```
STEP 1: Prepare verified data:
  data_points = [(0,2), (1,8), (2,28), (3,184), (4,1644)]
  n_values = [0, 1, 2, 3, 4]
  g_values = [2, 8, 28, 184, 1644]

STEP 2: Test polynomial hypothesis:
  - Using NumPy: polyfit(n_values, g_values, deg) for deg=2..5
  - For each degree: compute residuals, check if g(n) ∈ ℤ for n=5..16
  - Reject if any g(n) is non-integer or negative

STEP 3: Test recurrence relations (k=2,3,4):
  For k-th order: g(n) = c₁*g(n-1) + c₂*g(n-2) + ... + cₖ*g(n-k) + d
  - Using SymPy: Set up system of equations from known values
  - Solve for coefficients [c₁, ..., cₖ, d] using Rational arithmetic
  - Test: compute g(5), g(6) and verify integer results
  - Use rsolve() to find closed form if recurrence found

STEP 4: Symbolic regression (if no recurrence):
  - PySRRegressor configuration:
    * binary_operators=["+", "*", "-", "/"]
    * unary_operators=["square", "cube", "exp"]
    * niterations=50
    * populations=30
  - Fit on (n, g(n)) data
  - Extract top 5 formulas by complexity/accuracy
  - Evaluate each at n=5..16, verify integer constraint

STEP 5: Difference analysis:
  Δ¹g(n) = g(n+1) - g(n)
  Δ²g(n) = Δ¹g(n+1) - Δ¹g(n)
  Continue until differences show pattern or become constant
  - If Δᵏg(n) constant: g(n) is polynomial of degree k
  - If Δᵏg(n) forms geometric sequence: exponential component
```

**SUCCESS CRITERIA:**
- Identify formula or recurrence that fits all known values exactly
- Formula produces integer values for n=5..16
- Residuals < 0.1 for all data points

**CHAINING:**
- If formula found: → PROMPT 4 (compute g(16))
- If no pattern: → PROMPT 3 (try eigenvalue analysis)

---

## PROMPT 3: Recurrence Verification and OEIS Cross-Reference

**OBJECTIVE:** Verify formula and cross-reference with OEIS database

**DETERMINISTIC TOOLS:**
- NumPy: for recurrence computation
- oeis library: for sequence lookup
- SymPy: exact arithmetic verification

**COMPUTATIONAL PROCEDURE:**
```
STEP 1: Using formula/recurrence from Prompt 2:
  - Compute g(5), g(6), ..., g(10) using exact arithmetic
  - Verify all results are positive integers
  - Check consistency with known values g(0)..g(4)

STEP 2: OEIS lookup:
  from oeis import oeis
  - Query: oeis(sequence) with full sequence [2,8,28,184,1644,...]
  - Check partial matches with subsequences
  - Review metadata for related sequences

STEP 3: Cross-reference known formulas:
  - Check if matches: binomial sums, Catalan-like, projective plane counts
  - Verify against published sequences in combinatorics
```

**SUCCESS CRITERIA:**
- Recurrence/formula validated for g(5)..g(10)
- OEIS match documented OR confirmed novel sequence

**CHAINING:**
- If validated: → PROMPT 4 (compute g(16))
- If OEIS match with formula: use that formula directly

---

## PROMPT 4: Efficient Large-n Computation

**OBJECTIVE:** Compute g(16) exactly using validated formula

**DETERMINISTIC TOOLS:**
- NumPy or SymPy (depending on formula type)
- Exact integer/rational arithmetic

**COMPUTATIONAL PROCEDURE:**
```
STEP 1: Implement validated formula from Prompt 3
  - Use exact arithmetic (Integer or Rational)
  - No floating point operations

STEP 2: Compute g(16) directly:
  - If closed-form: evaluate at n=16
  - If recurrence: iterate from g(0)..g(4) to g(16)
  - Verify result is positive integer

STEP 3: Sanity checks:
  - Verify g(16) > g(4) (monotonicity)
  - Check magnitude is reasonable (not astronomical if geometric)
  - Recompute g(1)..g(4) to verify no errors
```

**SUCCESS CRITERIA:**
- Obtain single, exact integer value for g(16)
- Value passes sanity checks

**CHAINING:**
- → PROMPT 5 (structural verification)

---

## PROMPT 5: Structural Visualization and Verification

**OBJECTIVE:** Visual/structural confirmation of correctness

**DETERMINISTIC TOOLS:**
- Matplotlib: plotting
- NetworkX: incidence graph construction
- SymPy: geometric visualization

**COMPUTATIONAL PROCEDURE:**
```
STEP 1: For small n (e.g., n=2):
  - Construct incidence graph:
    * Nodes: all points (red, blue, white)
    * Edges: lines constructed
  - Visualize using NetworkX spring_layout
  - Verify structure matches expectations

STEP 2: Plot growth sequence:
  - X-axis: n (days 0..16)
  - Y-axis: g(n) (log scale if exponential)
  - Show verified points vs formula predictions
  - Overlay any OEIS matches

STEP 3: Statistical analysis:
  - Degree distribution of incidence graph
  - Clustering coefficient
  - Compare to known geometric structures
```

**SUCCESS CRITERIA:**
- Visual confirmation process matches problem description
- Growth curve matches mathematical prediction
- No geometric anomalies

**OUTPUT:**
- Final g(16) value with confidence level
- Visualization confirming correctness
- Formula/recurrence documentation

---

## RISKS & RECOMMENDATIONS

**RISKS:**
1. Symbolic regression may overfit with only 5 data points
2. OEIS may not contain this sequence
3. Recurrence coefficients may not have closed form
4. Computation may become intractable even with formula

**RECOMMENDATIONS:**
1. Verify each step against known values before proceeding
2. Use exact arithmetic throughout (no floats)
3. Document all intermediate results
4. If step fails, iterate with adjusted parameters
5. Consider computing g(5) directly to get 6th data point for PySR

---

## EXECUTION ORDER

```
START → PROMPT 1 (verify simulation, analyze ratios)
         ↓
      PROMPT 2 (fit formula/recurrence)
         ↓
      PROMPT 3 (verify + OEIS lookup)
         ↓
      PROMPT 4 (compute g(16))
         ↓
      PROMPT 5 (visualize + confirm)
         ↓
       ANSWER
```

**Implementation Status:**
- [ ] Prompt 1: prompt1_incidence_analysis.py (created)
- [ ] Prompt 2: prompt2_formula_fitting.py (pending)
- [ ] Prompt 3: prompt3_oeis_verification.py (pending)
- [ ] Prompt 4: prompt4_compute_g16.py (pending)
- [ ] Prompt 5: prompt5_visualization.py (pending)
